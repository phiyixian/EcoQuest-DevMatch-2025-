{
  "language": "Solidity",
  "sources": {
    "contracts/EcoQuestDonation.sol": {
      "content": "\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"./MockUSDC.sol\";\r\n\r\n/**\r\n * @title EcoQuestDonation\r\n * @dev Manages carbon offset donations and tracking\r\n */\r\ncontract EcoQuestDonation {\r\n    MockUSDC public usdcToken;\r\n    address public klimadao;\r\n    \r\n    // Total donations received\r\n    uint256 public totalDonations;\r\n    \r\n    // Total CO2 offset (in kg)\r\n    uint256 public totalCO2Offset;\r\n    \r\n    // Donation struct\r\n    struct Donation {\r\n        address donor;\r\n        uint256 amount;\r\n        uint256 co2Offset;\r\n        uint256 timestamp;\r\n        string message;\r\n    }\r\n    \r\n    // User stats\r\n    struct UserStats {\r\n        uint256 totalDonated;\r\n        uint256 totalCO2Offset;\r\n        uint256 donationCount;\r\n    }\r\n    \r\n    // Events\r\n    event DonationReceived(\r\n        address indexed donor,\r\n        uint256 amount,\r\n        uint256 co2Offset,\r\n        string message\r\n    );\r\n    \r\n    //\r\n    \r\n    // Mappings\r\n    mapping(address => UserStats) public userStats;\r\n    mapping(uint256 => Donation) public donations;\r\n    uint256 private _donationIds;\r\n    \r\n    constructor(address _usdcToken, address _klimadao) {\r\n        usdcToken = MockUSDC(_usdcToken);\r\n        klimadao = _klimadao;\r\n    }\r\n    \r\n    function offset(uint256 amount, uint256 co2Offset, string memory message) external {\r\n        require(amount > 0, \"Amount must be greater than 0\");\r\n        require(co2Offset > 0, \"CO2 offset must be greater than 0\");\r\n        bool success = usdcToken.transferFrom(msg.sender, klimadao, amount);\r\n        require(success, \"USDC transfer failed\");\r\n\r\n        _donationIds++;\r\n        uint256 donationId = _donationIds;\r\n\r\n        donations[donationId] = Donation({\r\n            donor: msg.sender,\r\n            amount: amount,\r\n            co2Offset: co2Offset,\r\n            timestamp: block.timestamp,\r\n            message: message\r\n        });\r\n\r\n        userStats[msg.sender].totalDonated += amount;\r\n        userStats[msg.sender].totalCO2Offset += co2Offset;\r\n        userStats[msg.sender].donationCount++;\r\n\r\n        totalDonations += amount;\r\n        totalCO2Offset += co2Offset;\r\n\r\n        emit DonationReceived(msg.sender, amount, co2Offset, message);\r\n    }\r\n    \r\n    function getUserStats(address user) external view returns (UserStats memory) {\r\n        return userStats[user];\r\n    }\r\n\r\n    function getDonation(uint256 donationId) external view returns (Donation memory) {\r\n        require(donationId > 0 && donationId <= _donationIds, \"Invalid donation ID\");\r\n        return donations[donationId];\r\n    }\r\n\r\n    function getTotalDonations() external view returns (uint256) {\r\n        return _donationIds;\r\n    }\r\n}"
    },
    "contracts/ETHUSDCSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./MockUSDC.sol\";\r\n\r\n/**\r\n * @title ETH to USDC Swap Contract\r\n * @dev A simple contract that allows users to swap ETH for USDC at a fixed rate\r\n * @notice This is for testnet demonstration purposes\r\n */\r\ncontract ETHUSDCSwap {\r\n    MockUSDC public usdcToken;\r\n    address public owner;\r\n    uint256 public exchangeRate; // How much USDC per 1 ETH (in wei)\r\n    \r\n    event ETHSwappedForUSDC(\r\n        address indexed user,\r\n        uint256 ethAmount,\r\n        uint256 usdcAmount\r\n    );\r\n    \r\n    event ExchangeRateUpdated(uint256 newRate);\r\n    event USDCWithdrawn(address indexed owner, uint256 amount);\r\n    event ETHWithdrawn(address indexed owner, uint256 amount);\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner can call this function\");\r\n        _;\r\n    }\r\n    \r\n    constructor(address _usdcToken, uint256 _exchangeRate) {\r\n        usdcToken = MockUSDC(_usdcToken);\r\n        owner = msg.sender;\r\n        exchangeRate = _exchangeRate; // e.g., 2000 * 10^6 for 2000 USDC per ETH\r\n    }\r\n    \r\n    /**\r\n     * @dev Swap ETH for USDC at the current exchange rate\r\n     * @notice Sends ETH and receives USDC in return\r\n     */\r\n    function swapETHForUSDC() external payable {\r\n        require(msg.value > 0, \"Must send ETH to swap\");\r\n        \r\n        // Calculate USDC amount to give\r\n        // exchangeRate is USDC per ETH (with 6 decimals for USDC)\r\n        uint256 usdcAmount = (msg.value * exchangeRate) / 1e18;\r\n        \r\n        // Check if contract has enough USDC\r\n        require(\r\n            usdcToken.balanceOf(address(this)) >= usdcAmount,\r\n            \"Insufficient USDC in contract\"\r\n        );\r\n        \r\n        // Transfer USDC to user\r\n        require(\r\n            usdcToken.transfer(msg.sender, usdcAmount),\r\n            \"USDC transfer failed\"\r\n        );\r\n        \r\n        emit ETHSwappedForUSDC(msg.sender, msg.value, usdcAmount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Get the current exchange rate\r\n     * @return The amount of USDC (with 6 decimals) per 1 ETH\r\n     */\r\n    function getExchangeRate() external view returns (uint256) {\r\n        return exchangeRate;\r\n    }\r\n    \r\n    /**\r\n     * @dev Calculate how much USDC you would get for a given amount of ETH\r\n     * @param ethAmount The amount of ETH (in wei)\r\n     * @return The amount of USDC (with 6 decimals)\r\n     */\r\n    function calculateUSDCAmount(uint256 ethAmount) external view returns (uint256) {\r\n        return (ethAmount * exchangeRate) / 1e18;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get the contract's current USDC balance\r\n     * @return The USDC balance of this contract\r\n     */\r\n    function getContractUSDCBalance() external view returns (uint256) {\r\n        return usdcToken.balanceOf(address(this));\r\n    }\r\n    \r\n    /**\r\n     * @dev Get the contract's current ETH balance\r\n     * @return The ETH balance of this contract\r\n     */\r\n    function getContractETHBalance() external view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n    \r\n    // Owner functions\r\n    \r\n    /**\r\n     * @dev Update the exchange rate (owner only)\r\n     * @param _newRate The new exchange rate (USDC per ETH with 6 decimals)\r\n     */\r\n    function updateExchangeRate(uint256 _newRate) external onlyOwner {\r\n        exchangeRate = _newRate;\r\n        emit ExchangeRateUpdated(_newRate);\r\n    }\r\n    \r\n    /**\r\n     * @dev Fund the contract with USDC (owner only)\r\n     * @param amount The amount of USDC to add to the contract\r\n     */\r\n    function fundWithUSDC(uint256 amount) external onlyOwner {\r\n        require(\r\n            usdcToken.transferFrom(msg.sender, address(this), amount),\r\n            \"USDC transfer failed\"\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev Withdraw USDC from the contract (owner only)\r\n     * @param amount The amount of USDC to withdraw\r\n     */\r\n    function withdrawUSDC(uint256 amount) external onlyOwner {\r\n        require(\r\n            usdcToken.balanceOf(address(this)) >= amount,\r\n            \"Insufficient USDC balance\"\r\n        );\r\n        require(\r\n            usdcToken.transfer(owner, amount),\r\n            \"USDC transfer failed\"\r\n        );\r\n        emit USDCWithdrawn(owner, amount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Withdraw ETH from the contract (owner only)\r\n     * @param amount The amount of ETH to withdraw (in wei)\r\n     */\r\n    function withdrawETH(uint256 amount) external onlyOwner {\r\n        require(address(this).balance >= amount, \"Insufficient ETH balance\");\r\n        payable(owner).transfer(amount);\r\n        emit ETHWithdrawn(owner, amount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Emergency withdraw all ETH (owner only)\r\n     */\r\n    function emergencyWithdrawETH() external onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        if (balance > 0) {\r\n            payable(owner).transfer(balance);\r\n            emit ETHWithdrawn(owner, balance);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Emergency withdraw all USDC (owner only)\r\n     */\r\n    function emergencyWithdrawUSDC() external onlyOwner {\r\n        uint256 balance = usdcToken.balanceOf(address(this));\r\n        if (balance > 0) {\r\n            require(\r\n                usdcToken.transfer(owner, balance),\r\n                \"USDC transfer failed\"\r\n            );\r\n            emit USDCWithdrawn(owner, balance);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Transfer ownership (owner only)\r\n     * @param newOwner The new owner address\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"New owner cannot be zero address\");\r\n        owner = newOwner;\r\n    }\r\n    \r\n    // Allow contract to receive ETH\r\n    receive() external payable {}\r\n}\r\n"
    },
    "contracts/MockUSDC.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/*Frontend tip:\r\n    Can make the user experience smoother by:\r\n    1. User only input donation amount once (not in both approve() and offset()\r\n            Asking the user for the donation amount once,\r\n            Then, in your frontend code, call approve(spender, amount) and\r\n            offset(amount) with the same value.\r\n    2. User nonid to input klimadao_contract address\r\n            Hardcode or configure the KlimadaoDonation contract address in your frontend code \r\n            (for example, in a config file or as a constant).*/\r\n\r\n/// @title MockUSDC - Simple ERC20 Token for Testing\r\ncontract MockUSDC {\r\n    string public name = \"Mock USDC\";\r\n    string public symbol = \"mUSDC\";\r\n    uint8 public decimals = 6;\r\n    uint256 public totalSupply;\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    constructor(uint256 _initialSupply) {\r\n        totalSupply = _initialSupply;\r\n        balanceOf[msg.sender] = _initialSupply;\r\n        emit Transfer(address(0), msg.sender, _initialSupply);\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool) {\r\n        require(balanceOf[from] >= amount, \"Insufficient balance\");\r\n        require(allowance[from][msg.sender] >= amount, \"Allowance exceeded\");\r\n        balanceOf[from] -= amount;\r\n        balanceOf[to] += amount;\r\n        allowance[from][msg.sender] -= amount;\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    // Add a transfer function for completeness (optional but standard)\r\n    function transfer(address to, uint256 amount) external returns (bool) {\r\n        require(balanceOf[msg.sender] >= amount, \"Insufficient balance\");\r\n        balanceOf[msg.sender] -= amount;\r\n        balanceOf[to] += amount;\r\n        emit Transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}